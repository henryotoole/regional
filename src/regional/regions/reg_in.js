// src/regions/reg_input.js
// Josh Reed 2024
//
// Main input region subclass file.

import {Region, RHElement} from "../regional.js"

/**
 * An input region is pretty much a regular region with a key piece of automation.
 * 
 * The usual information loop for a region is as follows:
 * `settings / data ---> graphical_render() ---> DOM ---> [user input] ---> control logic() ---> settings / data`
 * 
 * Usually, the control logic and render steps are complex enough that they must be written manually for every
 * distinct region. However, input cycles are so simple that those steps *can* be automated.
 * 
 * For example, it's very common to have a text `<input>` of some sort tied to a settings key in a region. The
 * setting key value ought to always match the `<input>` text, and vice versa. If the user alters the `<input>`
 * text, the setting key should update to match. If logic from elsewhere in the region or application alters the
 * settings key, then the `<input>` DOM should have its value altered on-screen accordingly.
 * 
 * This simple loop is easy to automate. As long as the conceptual data loop is indeed this simple, the region
 * associated with it can be quite complex. For example, a color picker can have several nested `<div>`'s and
 * many moving parts. However, ultimately all that's changing is a hex code and the data loop is identical.
 * 
 * This base RegIn class below provides the framework for this automation. More specific subclasses should
 * be created for more specific cases. Some basic ones are provided by Regional to bind to `<input>` tags,
 * `<textarea>` tags, and more.
 * 
 * ### Interacting with a Region Input ###
 * The 'value' of a RegIn should always be changed programatically by altering the settings key in the
 * super-region this input is bound to. Similarly, the value should be retrieved from that settings key as
 * well.
 * 
 * Creating and registering an input region is the same as any other:
 * `let reg_input = (new RegionInput()).fab().link(super_region, $el, "settings_key")`
 * **Notably** there's a third argument to the link() function.
 * 
 * 
 * ### Extending This Class ###
 * Child classes should:
 * 1. Bind event handlers as appropriate to call _view_alters_value()
 * 2. Create an _on_graphical_render() method that applies this.settings.value into the DOM and calls super()
 * 3. Create a Fabricator that allows autogeneration of the input and the validation failure message tags
 */
class RegIn extends Region
{
	/** @type {Number} If undefined, debouncer is disabled. If defined, the debouncer duration in seconds. */
	_debouncer_duration
	/** @type {Boolean} The number of debouncing actions that have occured within the operation */
	_debouncer_count = 0
	/** @type {string} Key at which the input value is stored in the settings object of superregion */
	_super_settings_key
	/** @descrption The last thing we pulled from the super-region settings key */
	_super_last_pulled
	/**
	 * @type {Function} If configured, the validation function for this input. Accepts one arg (the user-input
	 * value) and expected to return True or False, depending on validity of data.
	 */
	_val_fn
	/** @type {string} Message to display when validation fails */
	_val_fail_text
	/** @type {RHElement} The validation failure notice element, manually defined by external code*/
	_val_fail_notice_ovr
	/** @type {RHElement} The default validation failure notice element, generated by RegIn or child */
	_val_fail_notice_base
	/** @description Settings object for this region. This is local data which is erased on page refresh. */
	settings = {
		/** @description Local copy of the input value. This will always match the view. */
		value: undefined,
		/** @description Set to true if we are in 'validation failure' state. */
		val_failure_state: undefined,
	}

	/**
	 * Perform linking operations for this region:
	 * + Link this region to its super-region and vice versa
	 * + Link this region to the specific element in webpage DOM that it represents.
	 * + Link this region to the switchyard and datahandlers and setup certain events.
	 * + Assign a unique in-memory ID for this region and set the $reg_el's ID to the same.
	 * + Fabrication links (if fab() was called earlier), including links to this.$element and linking $elements
	 *   to the $reg_el.
	 * 
	 * @param {Region} reg_super The super (or parent) region that this region will be a subregion of.
	 * @param {HTMLElement} $reg_el The main element for this region, which this region will be bound to.
	 * @param {*} super_settings_ref Key at which the input value is stored in the settings object of superregion.
	 * 
	 * @returns {Region} itself for function call chaining
	 */
	link(reg_super, $reg_el, super_settings_key)
	{
		super.link(reg_super, $reg_el)

		this._super_settings_key = super_settings_key
	}

	/**
	 * @protected
	 * This should be called the child class whenever the 'value' for this input is altered by the user via
	 * the 'view' (e.g. the DOM rendered by the browser) as frequently as possible. For an <input> tag, this
	 * would be every keystroke, etc.
	 * 
	 * Commonly, this will take the form:
	 * `$el.addEventListener("input", (e) => {this.view_alters_value($el.value)});`
	 * 
	 * @param {*} value Whatever the value has changed to.
	 */
	_view_alters_value(value)
	{
		// If we are debouncing, use timeouts to report value.
		if(this._debouncer_duration)
		{
			console.log("Debouncing w/ value " + value)
			this._debouncer_count++
			window.setTimeout(function(original_debouncer_count, original_value)
			{
				console.log("Timeout callback w/ og_/current_count=" + original_debouncer_count + "/" + this._debouncer_count + ", og_val=" + original_value)
				// If, at the end of the timeout, the debouncer count has not changed, we prosecute.
				if(this._debouncer_count == original_debouncer_count)
				{
					this._view_alters_value_prosecute_update(original_value)
					this._debouncer_count = 0
				}
			}.bind(this, this._debouncer_count, value), this._debouncer_duration * 1000)
		}
		// Otherwise, report immediately
		else
		{
			this._view_alters_value_prosecute_update(value)
		}
	}

	/**
	 * @private
	 * 
	 * Called whenever value has actually changed post debouncer. At this stage, local value settings (model)
	 * is always altered to match. Then validation (if configured) occurs.
	 * 
	 * If validation fails for the current input, the local value (e.g. this.settings.value) will match but
	 * the new value will NOT be propagated 'upwards' to the superregion until the user corrects it.
	 * 
	 * @param {*} value Whatever the value has changed to.
	 */
	_view_alters_value_prosecute_update(value)
	{
		this.settings.value = value

		// If validation is enabled and the value fails it, set failed state and re-render
		if(this._val_fn && !this._val_fn(value))
		{
			this.settings.val_failure_state = true
		}
		// If validation isn't enabled or succeeds, propagate and unset failed state
		else
		{
			this.settings.val_failure_state = false
			this._view_alter_propagate(value)
		}

		// Always render in case failed state updated.
		this.graphical_render()
	}

	/**
	 * @private
	 * 
	 * Actually propagate the new value upwards to the model/settings of the superregion and re-render it.
	 * 
	 * @param {*} value Whatever the value has changed to. Will be validated if validation is enabled.
	 */
	_view_alter_propagate(value)
	{
		this.superregion.settings[this._super_settings_key] = value
		this.superregion.graphical_render()
	}

	/**
	 * Provide a validation function to this class, against which all user-input data will be validated.
	 * The function should take one argument (the value) and return true/false depending on whether the data
	 * was valid.
	 * 
	 * For example, a validation function to ensure input was a Number might resemble:
	 * `(value)=>{return (!isNaN(value))}`
	 * 
	 * If validation is enabled and input fails, then the value the user input will still wind up in
	 * `this.settings.value`. However, it will not propagate upwards to `superregion.settings` until the
	 * user fixes it. While the input is in this 'validation failure' mode, the configured 'validation notice'
	 * element will be shown.
	 * 
	 * @param {Function} fn The function to validate input values with.
	 * @param {string} failure_text The text that will appear in the 'error' notice given to the user.
	 */
	validation_set(fn, failure_text)
	{
		this._val_fn = fn
		this._val_fail_text = failure_text
	}

	/**
	 * Set the validation notice element manually. This element will be shown() when the input region is
	 * in 'validation failure' state and hidden when it is not. The innerHTML of this element will be set
	 * to a message describing the failure.
	 * 
	 * By default, all input regions have *some sort* of validation failure notice mechanism. The absolute
	 * default is to automatically generate a floating <div> tag. *Good* implementations of RegIn subclasses
	 * will define one in their Fabricators. However, if this method is called a custom one may be provided.
	 * 
	 * @param {HTMLElement} el_notice A notice element to hide() and show() as needed.
	 */
	validation_notice_setup(el_notice)
	{
		_val_fail_notice_ovr = RHElement.wrap(el_notice)
	}

	/**
	 * This will get the validation failure notice element, or generate it if it did not exist.
	 * 
	 * The fallbacks are as follows
	 * 1. Manual override is checked (e.g. validation_notice_setup())
	 * 2. Local already-set-up copy is checked (generated by Fabricator and stored at this._val_notice)
	 * 3. Local copy is generated
	 * 
	 * @returns {RHElement} The validation notice element to use for this input.
	 */
	_val_notice_get()
	{
		// 1.
		if(this._val_fail_notice_ovr) return this._val_fail_notice_ovr

		// 2.
		if(this._val_fail_notice_base) return this._val_fail_notice_base

		// 3.
		let notice = document.createElement("div")
		notice.style.position = "absolute"
		notice.style.backgroundColor = "white"
		notice.style.padding = '2px'
		this._val_fail_notice_base = RHElement.wrap(notice)
		return this._val_fail_notice_base
	}

	/**
	 * Set a debouncer for this input. When a debouncer is active, a series of view-value alterations that occurs
	 * with no more than the debouncing delay between updates will all be considered one update. This can be
	 * helpful when we don't wish to incur too many graphical_render() updates as values change.
	 * 
	 * @param {Number} duration_s The number of seconds to use when debouncing, or undefined to disable.
	 */
	debouncer_set(duration_s)
	{
		this._debouncer_duration = duration_s
	}
	
	/**
	 * @protected
	 * This is called whenever this specific region has its settings refreshed. This is the preferred location
	 * to setup settings information in a Region subclass.
	 */
	_on_settings_refresh()
	{
		this.settings.value = undefined
		this.settings.val_failure_state = false
	}

	/**
	 * Completely redraw this region and all active subregions. Overridden here to selectively pull from
	 * super-region settings value if it has changed from last time we pulled it.
	 */
	graphical_render()
	{
		/**
		 * This quirky behavior is needed to handle the state where the user has input invalid data and
		 * has not yet fixed it. The conduct of proper MVC dictates that the model must match the view
		 * and local settings must have the 'invalid' value until the usre fixes it. However, we don't
		 * wish to expose the invalid value to the rest of the site.
		 * 
		 * Thus, we prevent propagation from local- to region-value model/settings until the user fixes
		 * the problem. However, during that time render() calls may originate elsewhere. We don't
		 * want the model/settings value from the region to override the faulty data, as this would cause
		 * it to confusingly just dissapear.
		 * 
		 * So, we don't trigger an update UNLESS a programattic change has occured since we last read the
		 * variable.
		 */
		if(this.superregion.settings[this._super_settings_key] != this._super_last_pulled)
		{
			this.settings.value = this.superregion.settings[this._super_settings_key]
			this._super_last_pulled = this.settings.value
		}

		super.graphical_render()
	}

	/**
	 * @protected
	 * This is called whenever this specific region has its settings refreshed. This is the preferred location
	 * to actually place the code that will 'redraw' a region.
	 * 
	 * Don't forget to call super() on child classes!
	 */
	_on_graphical_render()
	{
		this._val_notice_get().innerHTML = this._val_fail_text
		this.settings.val_failure_state ? this._val_notice_get().show() : this._val_notice_get().hide()
	}
}

export {RegIn}